import { Fraction, type FractionInput } from "fraction.js";
import {
    getSetharesDissonance,
    type DissonanceParams,
    type DissonanceCurvePoint,
    type DissonanceCurveData,
} from "../lib";
import { ratioToCents, Spectrum } from "../primitives";
import { IntervalSet } from "../primitives/IntervalSet";

const DEFAULT_COLUMN_DELIMITER = ",";
const DEFAULT_ROW_DELIMITER = "\n";

export type DissonanceCurveOptions = DissonanceParams & {
    context: Spectrum;
    complement: Spectrum;
    maxDenominator?: number;
    start?: FractionInput;
    end?: FractionInput;
};

/**
 * Represents a dissonance curve calculated using Sethares' sensory dissonance model.
 * 
 * A dissonance curve shows how sensory dissonance varies across a range of intervals.
 * The curve is generated by:
 * 1. Creating a set of intervals between start and end ratios using IntervalSet.range()
 * 2. For each interval calculates dissonance between the context spectrum and complement spectrum transposed by that interval
 * 
 * @example
 * ```ts
 * const context = Spectrum.harmonicSeries(10, 440);
 * const complement = Spectrum.harmonicSeries(10, 440);
 * 
 * const curve = new DissonanceCurve({
 *   context,
 *   complement,
 *   start: 1,
 *   end: 2,
 *   maxDenominator: 60
 * });
 * 
 * // Get points sorted by interval
 * const points = curve.points;
 * 
 * // Get plot data with ratios
 * const plotData = curve.plot();
 * 
 * // Get plot data with cents
 * const plotDataCents = curve.plotCents();
 * ```
 */
export class DissonanceCurve {
    private _data: Map<string, DissonanceCurvePoint> = new Map();

    public readonly start: Fraction;
    public readonly end: Fraction;
    public readonly context: Spectrum;
    public readonly complement: Spectrum;
    public readonly maxDissonance: number = 0;

    constructor(opts: DissonanceCurveOptions) {
        const {
            context,
            complement,
            start,
            end,
            maxDenominator,
            ...dissonanceParams
        } = opts;

        this.context = context;
        this.complement = complement;

        this.start = new Fraction(start ?? 1);
        this.end = new Fraction(end ?? 2);

        if (this.start.compare(this.end) > 0)
            throw Error("startCents should be less or equal to endCents");

        const intervals = IntervalSet.affinitive(this.context, this.complement).densify(20)
        const ratios = intervals.getRatios();

        for (let i = 0; i < ratios.length; i++) {
            const interval = ratios[i]!;

            const dissonance = getSetharesDissonance(
                this.context,
                this.complement.toTransposed(interval),
                dissonanceParams
            );

            if (dissonance > this.maxDissonance)
                this.maxDissonance = dissonance;

            this._data.set(interval.toFraction(), { interval, dissonance });
        }
    }

    /**
     * Get all dissonance curve points sorted by interval ratio.
     * @returns Array of DissonanceCurvePoint objects sorted in ascending order by interval
     */
    get points() {
        return Array.from(this._data.values()).sort((a, b) => a.interval.compare(b.interval));
    }

    /**
     * Get a dissonance curve point for a specific ratio.
     * @param ratio - The interval ratio as FractionInput (number, string, array, object, or Fraction)
     * @returns The DissonanceCurvePoint for the given ratio, or undefined if not found
     */
    get(ratio: FractionInput) {
        return this._data.get(new Fraction(ratio).toFraction());
    }

    /**
     * Get plot points with intervals as ratio values (decimal numbers).
     * @returns Array of [ratio, dissonance] tuples suitable for plotting
     */
    plot(): [number, number][] {
        return this.points.map(({ interval, dissonance }) => [
            interval.valueOf(),
            dissonance,
        ]);
    }

    /**
     * Get plot points with intervals as cents values.
     * @returns Array of [cents, dissonance] tuples suitable for plotting
     */
    plotCents(): [number, number][] {
        return this.points.map(({ interval, dissonance }) => [
            ratioToCents(interval).valueOf(),
            dissonance,
        ]);
    }

    /**
     * Serialize the dissonance curve to a JSON object.
     * @returns DissonanceCurveData object
     */
    toJSON(): DissonanceCurveData {
        return this.points.map(({ interval, dissonance }) => ({
            interval: {
                n: Number(interval.n),
                d: Number(interval.d),
            },
            dissonance,
        }));
    }

    private getRowString(
        row: Array<number | string>,
        delimiter: string = DEFAULT_COLUMN_DELIMITER
    ) {
        if (row.length === 0) return "";

        let result = `${row[0]}`;

        for (let i = 1; i < row.length; i += 1) {
            result += `${delimiter}${row[i]}`;
        }

        return result;
    }

    public toString(
        columnDelimiter: string = DEFAULT_COLUMN_DELIMITER,
        rowDelimiter: string = DEFAULT_ROW_DELIMITER,
    ) {
        if (this._data.size === 0) return "";

        const headerRow = this.getRowString(
            ["Ratio", "Interval", "Interval (cents)", "Sensory dissonance"],
            columnDelimiter
        );

        let result = headerRow + rowDelimiter;

        for (const point of this.points) {
            result += this.getRowString([
                point.interval.toFraction(),
                point.interval.valueOf(),
                ratioToCents(point.interval).valueOf(),
                point.dissonance,
            ], columnDelimiter) + rowDelimiter;
        }

        return result;
    }

    public toCsvFileBuffer(
        columnDelimiter: string = DEFAULT_COLUMN_DELIMITER,
        rowDelimiter: string = DEFAULT_ROW_DELIMITER
    ) {
        const content = this.toString(columnDelimiter, rowDelimiter);

        // Return UTF-8 BOM + content as Buffer for Node.js writeFileSync
        return Buffer.concat([
            Buffer.from([0xef, 0xbb, 0xbf]),
            Buffer.from(content, "utf-8"),
        ]);
    }

    /**
     * Find the nearest calculated point for a given ratio.
     * Uses binary search to find the first point where given ratio <= current ratio.
     * If given ratio is greater than all calculated ratios, returns the last point.
     * @param ratio - The ratio to find
     * @returns The nearest DissonanceCurvePoint, or undefined if curve has no points
     */
    findNearestPoint(ratio: FractionInput): DissonanceCurvePoint | undefined {
        const points = this.points;
        if (points.length === 0) return undefined;

        const given = new Fraction(ratio);

        let left = 0;
        let right = points.length;

        while (left < right) {
            const mid = (left + right) >>> 1;
            const point = points[mid]!;
            if (given.compare(point.interval) <= 0) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return points[left] ?? points[points.length - 1]!;
    }
    // TODO: find closest point by cents
    // TODO: recalculate on parameters change
}
